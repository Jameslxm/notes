package com.lixm.notes.kotlinimport kotlinx.coroutines.*import kotlinx.coroutines.flow.*import org.junit.Testclass AsynchronousFlowTest {//    fun foo(): List<Int> = listOf(1,2,3)//    fun foo(): Sequence<Int> = sequence {//        for (i in 1..3){//            Thread.sleep(100)//            yield(i)//        }//    }//    @Test//    fun testAsynchronousFlow(){//        foo().forEach{//            println(it)//        }////    }//    suspend fun foo(): List<Int>{//        delay(100)//        return listOf(1,2,3)//    }//    fun foo(): Flow<Int> = flow {//        for (i in 1..3){//            println("==>foo1:"+System.currentTimeMillis())//            delay(100)//            println("==>foo2:"+System.currentTimeMillis())//            emit(i)//        }//    }    fun foo(): Flow<Int> = flow {        for (i in 1..3){            delay(100)            println("Emitting $")            emit(i)        }    }    @Test    fun testAsynchronousFlow() = runBlocking<Unit>{//        foo().forEach{//            println(it)//        }//        println("testAsynchronousFlow")        println("==>1:"+System.currentTimeMillis())        launch {            for (k in 1..3) {                println("==>22:"+System.currentTimeMillis())                delay(100)                println("I'm not blocked $k")                println("==>2:"+System.currentTimeMillis())            }        }        println("==>3:"+System.currentTimeMillis())        foo().collect { value ->            println("==>44:"+System.currentTimeMillis())            println(value)            println("==>4:"+System.currentTimeMillis())        }    }    @Test    fun testAsynchronousFlow2() = runBlocking<Unit>{        println("Calling foo...")        val flow = foo()        println("Calling collect...")        flow.collect{value -> println(value)}        println("Calling collect again...")        flow.collect{values -> println(values)}    }    @Test    fun testAsynchronousFlow3() = runBlocking<Unit>{        val flow = foo()        withTimeoutOrNull(250){            flow.collect{value -> println(value)}        }        println("Done")    }    @Test    fun testAsynchronousAsFlow() = runBlocking<Unit>{        (1..3).asFlow().collect{value -> println(value)}    }    suspend fun performRequest(request: Int):String{        delay(1000)        return "response $request"    }    @Test    fun testMap() = runBlocking<Unit>{        (1..3).asFlow()            .map{request -> performRequest(request)}            .collect { response -> println(response) }    }    fun numbers():Flow<Int> = flow{        try {            emit(1)            emit(2)            println("This line will not execute")            emit(3)        }finally {            println("Finally in numbers")        }    }    @Test    fun testTake() = runBlocking<Unit>{        numbers().take(2)            .collect { value -> println(value) }    }    @Test    fun testReduce() = runBlocking<Unit>{        val sum = (1..5).asFlow()            .map{it * it}            .reduce{a,b -> a + b}        print(sum)    }    @Test    fun testContinuous() = runBlocking<Unit>{        (1..5).asFlow()            .filter {                println("Filter $it")                it % 2 == 0            }            .map{                println("Map $it")                "string $it"            }            .collect {                println("Collect $it")                "collect $it"            }    }    fun foo1():Flow<Int> = flow {        kotlinx.coroutines.withContext(Dispatchers.IO) {            for (i in 1..3){                Thread.sleep(100)                emit(i)            }        }    }    @Test    fun testWithContext() = runBlocking<Unit>{        withContext(Dispatchers.IO){            foo1().collect{value -> println(value)}        }    }    fun log(msg : String) = println("[${Thread.currentThread().name}] $msg")    fun foo2() : Flow<Int> = flow{        for (i in 1..3){            Thread.sleep(100)            log("Emitting $i")            emit(i)        }    }.flowOn(Dispatchers.Default)    @Test    fun testFlowOn() = runBlocking<Unit> {        foo2().collect { value -> log("Collected $value") }    }}
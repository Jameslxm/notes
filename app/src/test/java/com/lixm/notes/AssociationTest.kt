package com.lixm.notesimport kotlinx.coroutines.*import org.junit.Testimport kotlin.system.measureTimeMillisclass AssociationTest {    @Test    fun testAssociation(){//        GlobalScope.launch {//            delay(1000)//            println("World")//        }//        println("Hello")//        Thread.sleep(2000L)        GlobalScope.launch {            delay(1000L)            println("World")        }        println("Hello")        runBlocking {            delay(2000L)        }    }    @Test    fun testMySuspendingFunction() = runBlocking<Unit> {        GlobalScope.launch {            delay(1000L)            println("World")        }        println("Hello")        delay(2000L)    }    @Test    fun testJoin() = runBlocking{//        val job = GlobalScope.launch {//            delay(1000L)//            println("World")//        }//        println("Hello")//        job.join()        launch {            delay(1000L)            println("World")        }        println("Hello")    }    @Test    fun testCoroutineScope() = runBlocking{        launch {            delay(200L)            println("Task from runBlocking")        }        coroutineScope{            launch {                delay(500L)                println("Task from nested launch")            }            delay(100L)            println("Task from coroutine scope")        }        println("Coroutine scope is over")    }    @Test    fun testSuspend() = runBlocking {        launch { doWorld() }        println("Hello")    }    private suspend fun doWorld() {        delay(100L)        println("World")    }    @Test    fun testRepeat() = runBlocking{//        repeat(100_000){//            launch {//                delay(1000L)//                println(".")//            }//        }        GlobalScope.launch {            repeat(1000){i ->                println("I'm sleeping $i ...")                delay(500L)            }        }        delay(2000L)    }    @Test    fun testAssociation2() = runBlocking<Unit> {        //        val time = measureTimeMillis1 {//            val one = doSomethingUsefulOne()//            val two = doSomethingUsefulTwo()//            println("The answer is ${one + two}")//        }//        println("Completed in $time ms")//            val one = doSomethingUsefulOne()//            val two = doSomethingUsefulTwo()//            println("The answer is ${one + two}")//        val time = measureTimeMillis {//            val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }//            val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }////            one.start()//            two.start()//            println("The answer is ${one.await() + two.await()}")//        }//        println("Completed in $time ms")//        val time = measureTimeMillis {//            println("The answer is ${concurrentSum()}")//        }//        println("Completed in $time ms")        try {            failedConcurrentSum()        } catch(e: ArithmeticException) {            println("Computation failed with ArithmeticException")        }    }    @Test    fun testAssociation3(){        val time = measureTimeMillis {            val one = somethingUsefulOneAsync()            val two = somethingUsefulTwoAsync()            runBlocking {                println("The answer is ${one.await() + two.await()}")            }        }        println("Completed in $time ms")    }    fun somethingUsefulOneAsync() = GlobalScope.async {        doSomethingUsefulOne()    }    fun somethingUsefulTwoAsync() = GlobalScope.async {        doSomethingUsefulTwo()    }    suspend fun doSomethingUsefulTwo(): Int {        delay(1000L)        return 29    }    suspend fun doSomethingUsefulOne(): Int {        delay(1000L)        return 13    }    suspend fun failedConcurrentSum():Int = coroutineScope {        val one = async<Int> {            try {                delay(3000) // 模拟一个长时间的运算                42            } finally {                println("First child was cancelled")            }        }        val two = async<Int> {            println("Second child throws an exception")            throw ArithmeticException()        }        one.await() + two.await()    }//    suspend fun concurrentSum():Int = coroutineScope {//        val one = async { doSomethingUsefulOne() }//        val two = async { doSomethingUsefulTwo() }//        one.await() + two.await()//    }    @Test    fun testDispatchers() = runBlocking<Unit>{        launch {            println("main runBlocking      : I'm working in thread ${Thread.currentThread().name}")        }        launch (Dispatchers.Unconfined){            println("Unconfined            : I'm working in thread ${Thread.currentThread().name}")        }        launch(Dispatchers.Default){            println("Default               : I'm working in thread ${Thread.currentThread().name}")        }        launch (newSingleThreadContext("MyOwnThread")){            println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")        }    }    @Test    fun testDispatchers2() = runBlocking<Unit>{        launch (Dispatchers.Unconfined){            println("Unconfined      : I'm working in thread ${Thread.currentThread().name}")            delay(500L)            println("Unconfined      : After delay in thread ${Thread.currentThread().name}")        }        launch{            println("main runBlocking: I'm working in thread ${Thread.currentThread().name}")            delay(1000L)            println("main runBlocking: After delay in thread ${Thread.currentThread().name}")        }    }    fun log(msg: String) = println("${Thread.currentThread().name} $msg")    @Test    fun testDispatchers3() = runBlocking<Unit>{        val a = async {            log("I'm computing a piece of the answer")            6        }        val b = async {            log("I'm computing another piece of the answer")            7        }        log("The answer is ${a.await() * b.await()}")    }    @Test    fun testThread(){        newSingleThreadContext("Cxt1").use { cxt1 ->            newSingleThreadContext("Cxt2").use { cxt2 ->                runBlocking(cxt1){                    log("Started in ctx1")                    withContext(cxt2){                        log("Working in ctx2")                    }                    log("Back to ctx1")                }            }        }    }    @Test    fun testCoroutineContext() = runBlocking<Unit>{        println("My job is ${coroutineContext[Job]}")    }    @Test    fun testGlobalScope() = runBlocking<Unit>{        val request = launch {            GlobalScope.launch {                println("job1: I run in GlobalScope and execute independently!")                delay(1000L)                println("job1: I am not affected by cancellation of the request")            }            launch {                delay(100L)                println("job2: I am a child of the request coroutine")                delay(1000L)                println("job2: I will not execute this line if my parent request is cancelled")            }        }        delay(500L)        request.cancel()        delay(1000L)        println("main: Who has survived request cancellation?")    }    @Test    fun testtestDispatchers4() = runBlocking<Unit>{        val request = launch {            repeat(3){i ->                launch {                    delay((i+1)*200L)                    println("Coroutine $i is done")                }            }            println("request: I'm done and I don't explicitly join my children that are still active")        }        request.join()        println("Now processing of the request is complete")    }    @Test    fun testCoroutineName() = runBlocking<Unit>{        log("Started main coroutine")        val v1 = async(CoroutineName("v1coroutine")) {            delay(500)            log("Computing v1")            252        }        val v2 = async (CoroutineName("v2coroutine")){            delay(1000)            log("Computing v2")            6        }        log("The answer for v1 / v2 = ${v1.await() / v2.await()}")    }    @Test    fun testDispatchers4() = runBlocking<Unit> {        launch( Dispatchers.Default + CoroutineName("test") ) {            println("I'm working in thread ${Thread.currentThread().name}")        }    }    @Test    fun testMain()= runBlocking<Unit>{        val activity = Activity()        activity.doSomething()        println("Launched coroutines")        delay(500L)        println("Destroying activity!")        activity.destory()        delay(1000)    }}
package com.lixm.notes.encryptedfileimport android.os.Bundleimport android.view.Viewimport androidx.appcompat.app.AppCompatActivityimport androidx.security.crypto.EncryptedFileimport androidx.security.crypto.EncryptedSharedPreferencesimport androidx.security.crypto.MasterKeysimport com.lixm.notes.Rimport com.lxm.libutils.util.FileUtilsimport com.lxm.libutils.util.LogUtilimport com.lxm.libutils.util.SDCardUtilsimport kotlinx.android.synthetic.main.activity_encrypted_file.*import java.io.ByteArrayOutputStreamimport java.io.Fileimport java.io.FileOutputStreamimport java.io.IOExceptionimport java.nio.charset.Charsetclass EncryptedFileActivity : AppCompatActivity() {    val keyGenparameterSpec = MasterKeys.AES256_GCM_SPEC    val masterKeyAlias = MasterKeys.getOrCreate(keyGenparameterSpec)    var rootPath = SDCardUtils.getRootPath() + File.separator+"notes"    var file  = File(rootPath, "my_sensitive_data.txt")    val fileName = "sp_login"     val keyType = "key_type"    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_encrypted_file)    }    fun writeData(view: View){        Thread{            try {                val saveFolder = rootPath                val saveFileFolder = File(saveFolder)                if (!FileUtils.isFolderExist(saveFolder)) {                    saveFileFolder.mkdirs()                }            } catch (e: Exception) {            }            val encryptedFile = EncryptedFile.Builder(                file,                this,                masterKeyAlias,                EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB            ).build()// Write to a file.            try {                if(file.exists()){                    file.delete()                }                val outputStream: FileOutputStream? = encryptedFile.openFileOutput()                outputStream?.apply {                    write("MY SUPER SECRET INFORMATION"                        .toByteArray(Charset.forName("UTF-8")))                    flush()                    close()                }            } catch (ex: IOException) {                LogUtil.d(ex.toString(),true)                // Error occurred opening file for writing.            }        }.start()    }    fun readData(view: View){        Thread{            if(!FileUtils.isFileExist(file.absolutePath)){                return@Thread            }            lateinit var byteStream: ByteArrayOutputStream            val encryptedFile = EncryptedFile.Builder(                file,                view.context,                masterKeyAlias,                EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB            ).build()            try {                encryptedFile.openFileInput().use { fileInputStream ->                    try {                        byteStream = ByteArrayOutputStream()                        var nextByte = fileInputStream.read()                        while (nextByte != -1) {                            byteStream.write(nextByte)                            nextByte = fileInputStream.read()                        }                        val fileContents = byteStream.toByteArray()                        runOnUiThread{                            tvContent.text = String(fileContents)                        }                    } catch (ex: Exception) {                        // Error occurred opening raw file for reading.                    } finally {                        fileInputStream.close()                    }                }            } catch (ex: IOException) {                // Error occurred opening encrypted file for reading.            }        }.start()    }    fun readOriginData(view: View){        Thread{            if(!FileUtils.isFileExist(file.absolutePath)){                return@Thread            }            val fileToRead = file.absolutePath            var contentSb = FileUtils.readFile(fileToRead,"UTF-8")            var content = contentSb.toString()            runOnUiThread{                tvContent.text = content            }        }.start()    }    fun spWrite(view: View){        val sharedPreferences = EncryptedSharedPreferences.create(            fileName,masterKeyAlias,view.context,            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM        )        var sharedPrefsEditor = sharedPreferences.edit()        sharedPrefsEditor.putInt(keyType,2)        sharedPrefsEditor.commit()    }    fun spRead(view: View){        val sharedPreferences = EncryptedSharedPreferences.create(            fileName,masterKeyAlias,view.context,            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM        )        var type = sharedPreferences.getInt(keyType, -1)        runOnUiThread{            tvContent.text =""+type        }    }    fun spReadEncryption(view: View){//        var type = sharedPreferences.getInt(keyType, -1)//        runOnUiThread{//            tvContent.text =""+type//        }    }}